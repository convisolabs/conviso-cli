# Pentest Tasks Guide (Conviso CLI)

This guide explains how to define requirements with YAML tasks and run them from the CLI to register findings in Conviso Platform.

## Overview
1. Create a requirement in Conviso Platform and put the YAML in the **activity description**.
2. Run `tasks run` from the CLI for the project.
3. The CLI executes the commands, parses output, and creates assets/vulnerabilities.

## Execution
- Dry-run only (default): `python -m conviso.app tasks run --company-id 443 --project-id 26102`
- Apply directly: `python -m conviso.app tasks run --company-id 443 --project-id 26102 --apply`
- Approve commands without prompt: `python -m conviso.app tasks run --company-id 443 --project-id 26102 --auto-approve`
- Command approvals are stored locally in `~/.config/conviso/approved_tasks.json` and are keyed by the full command string.
- Manage approvals:
  - List approvals: `python -m conviso.app tasks approvals list`
  - Clear approvals: `python -m conviso.app tasks approvals clear`
  - Remove approval by hash: `python -m conviso.app tasks approvals remove --hash <hash>`

## Minimal YAML Structure
```yaml
version: 1
name: "My task"
steps:
  - id: step_1
    name: "Step 1"
    run:
      cmd: "echo 'hello'"
      parse:
        format: "scan-json-lines"
    actions:
      - type: "vulns.create"
        map:
          title: "${finding.title}"
```

Required blocks:
- `run.cmd`
- `run.parse.format`
- `actions` with `type` and `map`

Example files:
- `samples/task-assets-create.yaml`
- `samples/task-assets-update.yaml`
- `samples/task-nmap-nuclei.yaml`
- `samples/task-nuclei.yaml`
- `samples/task-naabu.yaml`

## Supported Actions
- `assets.create`
- `assets.update`
- `assets.enrich`
- `vulns.create`

`assets.enrich` only updates existing assets (requires `id`/`assetId` or `name`); it does not create new assets.

Minimal example:
```yaml
version: 1
name: "Enrich asset"
steps:
  - id: enrich_asset
    name: "Enrich asset"
    run:
      cmd: "echo '{\"name\": \"example.com\", \"businessImpact\": \"HIGH\", \"dataClassification\": \"SENSITIVE\"}'"
      parse:
        format: "scan-json-lines"
    actions:
      - type: "assets.enrich"
        map:
          name: "${finding.name}"
          businessImpact: "${finding.businessImpact}"
          dataClassification: "${finding.dataClassification}"
```

## Assets Fields
Allowed fields for `assets.create` and `asset.map` (used by `create_if_missing`):
- `name`, `description`, `businessImpact`, `dataClassification`, `assetsTagList`, `integrations`, `environmentCompromised`, `exploitability`

Allowed fields for `assets.update`:
- `id` or `assetId`, plus the same fields as `assets.create`

Minimal example:
```yaml
version: 1
name: "Update asset"
steps:
  - id: update_asset
    name: "Update asset"
    run:
      cmd: "echo '{\"id\": 123, \"exploitability\": \"INTERNET_FACING\"}'"
      parse:
        format: "scan-json-lines"
    actions:
      - type: "assets.update"
        map:
          id: "${finding.id}"
          exploitability: "${finding.exploitability}"
```

## Supported Parse Formats
- `nuclei-json-lines`
- `nmap-xml`
- `scan-json-lines` (recommended for any tool)

## scan-json-lines (recommended)
Each line is a JSON object. If `finding` exists, it is used; otherwise the whole object is treated as `finding`.

Minimal example:
```json
{"finding":{"type":"WEB","title":"X-Frame-Options Missing","description":"...","severity":"info","asset":"example.com","url":"https://example.com","method":"GET","scheme":"HTTPS","port":443,"request":"...","response":"..."}}
```

Automatic normalizations:
- `title` -> `name` (if `name` missing)
- `asset` -> `host` (if `host` missing)
- `matchedAt` -> `url` (if `url` missing)

## Target Sources From Project
Use `inputs.targets` to pull data from the project:

- `source: "project.target_urls"` (pentest projects only)
- `source: "project.assets"` (any project)

### Example: Targets -> Nuclei
```yaml
version: 1
name: "Nuclei scan (project targets)"
steps:
  - id: nuclei_targets
    name: "Nuclei scan using Project Target URLs"
    inputs:
      targets:
        source: "project.target_urls"
        export:
          file: ".task/targets.txt"
    run:
      cmd: "nuclei -l ${targets.file} -jsonl -include-rr"
      parse:
        format: "nuclei-json-lines"
    actions:
      - type: "vulns.create"
        asset:
          create_if_missing: true
          map:
            name: "${finding.host}"
        map:
          assetId: "${assets.by_name:finding.host}"
          title: "${finding.name}"
          description: "${finding.description}"
          severity: "${finding.severity}"
          solution: "${finding.solution}"
          method: "${finding.method}"
          scheme: "${finding.scheme}"
          url: "${finding.url}"
          port: "${finding.port}"
          request: "${finding.request}"
          response: "${finding.response}"
          reference: "${finding.reference}"
```

### Example: Targets -> Hosts (for subfinder/naabu)
Some tools require **hosts only**. Use `export.mode: "hosts"` to normalize URLs:

```yaml
inputs:
  targets:
    source: "project.target_urls"
    export:
      file: ".task/targets.txt"
      mode: "hosts"
```

## Naabu Adapter (scan-json-lines)
Use the adapter to convert Naabu JSON output into `scan-json-lines`:

```yaml
version: 1
name: "Subfinder + DNSX + Naabu (from Target URLs)"
steps:
  - id: recon_ports
    name: "Subdomains -> resolve -> port scan"
    inputs:
      targets:
        source: "project.target_urls"
        export:
          file: ".task/targets.txt"
          mode: "hosts"
    run:
      cmd: "subfinder -dL ${targets.file} -silent | dnsx -silent | naabu -list /dev/stdin -json | python3 tools/naabu_to_scan_jsonl.py"
      parse:
        format: "scan-json-lines"
    actions:
      - type: "vulns.create"
        asset:
          create_if_missing: true
          map:
            name: "${finding.asset}"
        map:
          assetId: "${assets.by_name:finding.asset}"
          title: "${finding.title}"
          description: "${finding.description}"
          severity: "${finding.severity}"
          address: "${finding.address}"
          protocol: "${finding.protocol}"
          port: "${finding.port}"
          attackVector: "${finding.attackVector}"
```

## Troubleshooting
- **Invalid YAML**: indentation matters. Use 2 spaces.
- **No findings**: the tool produced no results or the pipeline is empty.
- **Missing assetId**: make sure `assetId` maps to a known asset or `create_if_missing: true`.
